'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _events = require('events');

var _nodeUuid = require('node-uuid');

var _nodeUuid2 = _interopRequireDefault(_nodeUuid);

var _lodash = require('lodash');

var _lodash2 = _interopRequireDefault(_lodash);

var _highland = require('highland');

var _highland2 = _interopRequireDefault(_highland);

var _WebSocketGremlinConnection = require('./WebSocketGremlinConnection');

var _WebSocketGremlinConnection2 = _interopRequireDefault(_WebSocketGremlinConnection);

var _MessageStream = require('./MessageStream');

var _MessageStream2 = _interopRequireDefault(_MessageStream);

var _executeHandler = require('./executeHandler');

var _executeHandler2 = _interopRequireDefault(_executeHandler);

var _utils = require('./utils');

var Utils = _interopRequireWildcard(_utils);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /*jslint -W079 */
/*jslint node: true */


var GremlinClient = function (_EventEmitter) {
  _inherits(GremlinClient, _EventEmitter);

  function GremlinClient() {
    var port = arguments.length <= 0 || arguments[0] === undefined ? 8182 : arguments[0];
    var host = arguments.length <= 1 || arguments[1] === undefined ? 'localhost' : arguments[1];
    var options = arguments[2];

    _classCallCheck(this, GremlinClient);

    var _this = _possibleConstructorReturn(this, Object.getPrototypeOf(GremlinClient).call(this));

    _this.port = port;
    _this.host = host;

    _this.options = _extends({
      language: 'gremlin-groovy',
      session: false,
      op: 'eval',
      processor: '',
      accept: 'application/json',
      executeHandler: _executeHandler2.default
    }, options);

    _this.useSession = _this.options.session;

    if (_this.useSession) {
      _this.sessionId = _nodeUuid2.default.v1();
    }

    _this.connected = false;
    _this.queue = [];

    _this.commands = {};

    _this.connection = _this.createConnection({ port: port, host: host });
    return _this;
  }

  _createClass(GremlinClient, [{
    key: 'createConnection',
    value: function createConnection(_ref) {
      var _this2 = this;

      var port = _ref.port;
      var host = _ref.host;

      var connection = new _WebSocketGremlinConnection2.default({ port: port, host: host });

      connection.on('open', function () {
        return _this2.onConnectionOpen();
      });
      connection.on('error', function (error) {
        return _this2.handleError(error);
      });
      connection.on('message', function (message) {
        return _this2.handleProtocolMessage(message);
      });
      connection.on('close', function (event) {
        return _this2.handleDisconnection(event);
      });

      return connection;
    }
  }, {
    key: 'handleError',
    value: function handleError(err) {
      this.connected = false;
      this.emit('error', err);
    }

    /**
     * Process all incoming raw message events sent by Gremlin Server, and dispatch
     * to the appropriate command.
     *
     * @param {MessageEvent} event
     */

  }, {
    key: 'handleProtocolMessage',
    value: function handleProtocolMessage(message) {
      var rawMessage = JSON.parse(message.data || message); // Node.js || Browser API
      var requestId = rawMessage.requestId;
      var _rawMessage$status = rawMessage.status;
      var statusCode = _rawMessage$status.code;
      var statusMessage = _rawMessage$status.message;
      var messageStream = this.commands[requestId].messageStream;


      switch (statusCode) {
        case 200:
          // SUCCESS
          delete this.commands[requestId]; // TODO: optimize performance
          messageStream.push(rawMessage);
          messageStream.push(null);
          break;
        case 204:
          // NO_CONTENT
          messageStream.push(null);
          break;
        case 206:
          // PARTIAL_CONTENT
          messageStream.push(rawMessage);
          break;
        default:
          messageStream.emit('error', new Error(statusMessage + ' (Error ' + statusCode + ')'));
          break;
      }
    }

    /**
     * Handle the WebSocket onOpen event, flag the client as connected and
     * process command queue.
     */

  }, {
    key: 'onConnectionOpen',
    value: function onConnectionOpen() {
      this.connected = true;
      this.emit('connect');

      this.executeQueue();
    }
  }, {
    key: 'handleDisconnection',


    /**
     * @param {CloseEvent} event
     */
    value: function handleDisconnection(event) {
      this.cancelPendingCommands({
        message: 'WebSocket closed',
        details: event
      });
    }
  }, {
    key: 'executeQueue',


    /**
     * Process the current command queue, sending commands to Gremlin Server
     * (First In, First Out).
     */
    value: function executeQueue() {
      while (this.queue.length > 0) {
        var _queue$shift = this.queue.shift();

        var message = _queue$shift.message;

        this.sendMessage(message);
      }
    }
  }, {
    key: 'cancelPendingCommands',


    /**
     * @param {Object} reason
     */
    value: function cancelPendingCommands(_ref2) {
      var message = _ref2.message;
      var details = _ref2.details;

      var commands = this.commands;
      var command = undefined;
      var error = new Error(message);
      error.details = details;

      // Empty queue
      this.queue.length = 0;
      this.commands = {};

      Object.keys(commands).forEach(function (key) {
        command = commands[key];
        command.messageStream.emit('error', error);
      });
    }
  }, {
    key: 'buildMessage',


    /**
     * For a given script string and optional bound parameters, build a protocol
     * message object to be sent to Gremlin Server.
     *
     * @param {String|Function} script
     * @param {Object} bindings
     * @param {Object} message
     */
    value: function buildMessage(rawScript) {
      var rawBindings = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];
      var baseMessage = arguments.length <= 2 || arguments[2] === undefined ? {} : arguments[2];

      var _Utils$buildQueryFrom = Utils.buildQueryFromSignature(rawScript, rawBindings);

      var gremlin = _Utils$buildQueryFrom.gremlin;
      var bindings = _Utils$buildQueryFrom.bindings;
      var _options = this.options;
      var processor = _options.processor;
      var op = _options.op;
      var accept = _options.accept;
      var language = _options.language;


      var baseArgs = { gremlin: gremlin, bindings: bindings, accept: accept, language: language };
      var args = _lodash2.default.defaults(baseMessage.args || {}, baseArgs);

      var message = _extends({
        requestId: _nodeUuid2.default.v1(),
        processor: processor,
        op: op,
        args: args
      }, baseMessage);

      if (this.useSession) {
        // Assume that people want to use the 'session' processor unless specified
        message.processor = message.processor || processor || 'session';
        message.args.session = this.sessionId;
      }

      return message;
    }
  }, {
    key: 'sendMessage',
    value: function sendMessage(message) {
      var serializedMessage = JSON.stringify(message);
      this.connection.sendMessage(serializedMessage);
    }
  }, {
    key: 'execute',


    /**
     * Asynchronously send a script to Gremlin Server for execution and fire
     * the provided callback when all results have been fetched.
     *
     * This method internally uses a stream to handle the potential concatenation
     * of results.
     *
     * Callback signature: (Error, Array<result>)
     *
     * @public
     * @param {String|Function} script
     * @param {Object} bindings
     * @param {Object} message
     * @param {Function} callback
     */
    value: function execute(script) {
      var bindings = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];
      var message = arguments.length <= 2 || arguments[2] === undefined ? {} : arguments[2];

      var callback = arguments.length <= arguments.length - 3 - 1 + 3 ? undefined : arguments[arguments.length - 3 - 1 + 3];

      if (typeof message === 'function') {
        callback = message;
        message = {};
      }

      var messageStream = this.messageStream(script, bindings, message);

      // TO CHECK: errors handling could be improved
      // See https://groups.google.com/d/msg/nodejs/lJYT9hZxFu0/L59CFbqWGyYJ
      // for an example using domains
      var executeHandler = this.options.executeHandler;


      executeHandler(messageStream, callback);
    }

    /**
     * Execute the script and return a stream of distinct/single results.
     * This method reemits a distinct data event for each returned result, which
     * makes the stream behave as if `resultIterationBatchSize` was set to 1.
     *
     * If you do not wish this behavior, please use client.messageStream() instead.
     *
     * Even though this method uses Highland.js internally, it does not return
     * a high level Highland readable stream so we do not risk having to deal
     * with unexpected API breaking changes as Highland.js evolves.
     *
     * @return {ReadableStream} A Node.js Stream2
     */

  }, {
    key: 'stream',
    value: function stream(script, bindings, message) {
      var messageStream = this.messageStream(script, bindings, message);
      var _ = _highland2.default; // override lo-dash locally

      // Create a local highland 'through' pipeline so we don't expose
      // a Highland stream to the end user, but a standard Node.js Stream2
      var through = _.pipeline(_.map(function (_ref3) {
        var data = _ref3.result.data;
        return data;
      }), _.sequence());

      var rawStream = messageStream.pipe(through);

      messageStream.on('error', function (e) {
        rawStream.emit('error', new Error(e));
      });

      return rawStream;
    }
  }, {
    key: 'messageStream',


    /**
     * Execute the script and return a stream of raw messages returned by Gremlin
     * Server.
     * This method does not reemit one distinct data event per result. It directly
     * emits the raw messages returned by Gremlin Server as they are received.
     *
     * Although public, this is a low level method intended to be used for
     * advanced usages.
     *
     * @public
     * @param {String|Function} script
     * @param {Object} bindings
     * @param {Object} message
     * @return {MessageStream}
     */
    value: function messageStream(script, bindings, rawMessage) {
      var stream = new _MessageStream2.default({ objectMode: true });

      var command = {
        message: this.buildMessage(script, bindings, rawMessage),
        messageStream: stream
      };

      this.sendCommand(command); //todo improve for streams

      return stream;
    }
  }, {
    key: 'sendCommand',


    /**
     * Send a command to Gremlin Server, or add it to queue if the connection
     * is not established.
     *
     * @param {Object} command
     */
    value: function sendCommand(command) {
      var message = command.message;
      var requestId = command.message.requestId;


      this.commands[requestId] = command;

      if (this.connected) {
        this.sendMessage(message);
      } else {
        this.queue.push(command);
      }
    }
  }]);

  return GremlinClient;
}(_events.EventEmitter);

exports.default = GremlinClient;